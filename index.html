<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Fourier Cube</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='256' height='256'%3E%3Cpath fill='%238c0d0d' d='M14.214 132.113l144.047 88.471 3.545-120.201-35.121-8.418-112.471 40.148z'/%3E%3Cpath fill='%23a62626' d='M.74 44.941l13.474 87.172 112.471-40.148-.172-27.282L.74 44.941z'/%3E%3Cpath fill='%23d95959' d='M161.806 100.383l-35.121-8.418-.172-27.282 36.196 5.594-.903 30.106z'/%3E%3Cg%3E%3Cpath fill='%230d8c0d' d='M161.806 100.383l82.471 20.765-86.016 99.436 3.545-120.201z'/%3E%3Cpath fill='%2359d959' d='M244.277 121.148l-82.471-20.765.903-30.106 92.551-28.06-10.983 78.931z'/%3E%3C/g%3E%3Cg%3E%3Cpath fill='%235959d9' d='M126.009 35.416l.504 29.267 36.196 5.594 92.551-28.06-129.251-6.801z'/%3E%3Cpath fill='%232626a6' d='M126.009 35.416l.504 29.267L.74 44.941l125.269-9.525z'/%3E%3C/g%3E%3C/svg%3E" type="image/svg+xml" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

  <style>
    * {
      box-sizing: border-box;
    }
    html {
      height: 100%;
      margin: 0;
      accent-color: #0ac;
      font-family: sans-serif;
      font-size: 0.9em;
    }
    body {
      margin: 0;
      min-height: 100%;
      display: grid;
      gap: 1em;
      grid-template-rows: repeat(4, 1fr);
      grid-template-columns: minmax(26em, 1fr) 4fr minmax(26em, 1fr);
      align-items: start;
      max-height: 100%;
    }

    .canvas {
      width: 100%;
      grid-column: 1 / -1;
      grid-row: 1 / -1;
      align-self: stretch;
      justify-self: stretch;
      z-index: 1;
    }

    .left {
      z-index: 2;
      grid-column: 1;
      grid-row: 1 / -1;
      max-height: 100%;
      overflow-y: auto;
    }

    .right {
      z-index: 2;
      grid-column: -2;
      grid-row: 1 / -1;
      max-height: 100%;
      overflow-y: auto;
    }

    .overlay {
      background: #fffc;
      margin: 1em;
      padding: 1em;
      border: 2px solid #fff;
    }

    .overlay-head {
      margin-bottom: 1em;
    }

    h2 {
      margin: 0 0 0;
    }

    .control-panel {
      display: grid;
      grid-template-columns: max-content 1fr max-content;
      justify-items: stretch;
      align-items: center;
      gap: 0.4rem 1em;
    }

    .control-panel-inner {
      display: contents;
    }

    .control-panel dd {
      margin:  0;
    }

    .input-field {
      width: 100%;
      padding: 0.5em;
      margin: 0;
      vertical-align: middle;
      font:  inherit;
    }

    .output-field {
      min-width: 3em;
      text-align: right;
      font:  inherit;
    }

    .output-field.center {
      text-align: center;
    }

    .button {
      width: 100%;
      padding: 0.5rem;
      margin: 0;
      vertical-align: middle;
      cursor: pointer;
      font:  inherit;
    }

    .control-panel-head {
      grid-column: 1 / -1;
      margin: 0;
    }

    .button-row {
      display: grid;
      margin: 0;
      list-style: none;
      padding: 0;
      gap:  1em;
      grid-template-columns: repeat(auto-fit, minmax(3em, 1fr));
      justify-items: stretch;
      align-items: stretch;
    }

    .checkbox-row {
      margin: 0;
      list-style: none;
      padding: 0;
      gap: 1em 0.5em;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
    }

    .button.big {
      font-size: 1.3em;
      padding: 0.3em 0.1em;
      display: block;
      font-weight: lighter;
      background-color: var(--prim-color, #333);
      border-radius: 0.2rem;
      border: 2px solid white;
      color: #fff;
    }

    .button.small {
      font-size: 1em;
      align-self: center;
      margin-bottom: 1em;
      justify-self: end;
      padding: 0.3em 0.5em;
      display: block;
      font-weight: lighter;
      background-color: #444;
      border: none;
      color: #fff;
    }

    .checkbox-label {
      white-space: nowrap;
      cursor: pointer;
    }

    .styled-checkbox-label {
      position: relative;
      padding: 0.4em 0.5em 0.4em 0.2em;
      cursor: pointer;
      white-space: nowrap;
    }

    .styled-checkbox:checked + .checkbox-background {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: -1;
    }

    .alttext.active-a > .placeholder,
    .alttext.active-a > .alt-b {
      display: none;
    }

    .alttext.active-b > .placeholder,
    .alttext.active-b > .alt-a {
      display: none;
    }

    summary {
      cursor: pointer;
    }

    @media (max-width: 70em) {
      body {
        grid-template-columns: 1fr;
        grid-template-rows: 70vh;
        grid-auto-rows: auto;
        align-items: start;
        max-height: 100%;
        gap: 0;
      }

      .left {
        grid-column: 1 / -1;
        grid-row: 2;
        position: sticky;
        top: 10em;
      }

      .right {
        grid-column: 1 / -1;
        grid-row: 3;
      }

      .canvas {
        grid-column: 1/ -1;
        grid-row: 1 / 1;
        position: sticky;
        top: 0;
        bottom: 0;
        width: 100%;
        height: 100%;
      }

      .camera-panel {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        margin: 0;
      }

      .camera-panel h2 {
        display: none;
      }

      .checkbox-row {
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body>
    <canvas class="canvas" id="c"></canvas>
    <div class="left">
      <div class="overlay generator-panel">
        <form id="spectrum-form" class="control-panel" onsubmit="event.preventDefault()" oninput="document.getElementsByName('axislabel')[0].classList.toggle('active-a', domain.value!='signal'); document.getElementsByName('axislabel')[0].classList.toggle('active-b',  domain.value=='signal');
        loadSpectrum(4096, domain.value, generator.value, amplitude.valueAsNumber, phase_constant.valueAsNumber, phase_linear.valueAsNumber, frequency_shift.valueAsNumber, Math.pow(2,bandwidth.valueAsNumber), freq_slice_a.valueAsNumber, freq_slice_b.valueAsNumber, freq_slice_zoom.valueAsNumber)">

          <h2 class="overlay-head" style="grid-column: span 2;">Generate</h2>
          <button style="float: right" class="button small" type="reset" onclick="this.form.reset(); this.dispatchEvent(new Event('input',{bubbles:true})); event.preventDefault()">Reset</button>
          <dl class="control-panel-inner">
            <dt>
              <label for="bandwidth">Domain</label>
            </dt>
            <dd style="grid-column: span 2;">
              <ul class="checkbox-row">
                <li><label class="styled-checkbox-label" style="accent-color: darkred"><input type="radio" class="styled-checkbox" name="domain" value="signal" checked  /> Signal<i class="checkbox-background" style="background-color: darkred;"></i></label></li>
                <li><label class="styled-checkbox-label" style="accent-color: darkgreen"><input type="radio" class="styled-checkbox" name="domain" value="spectrum"/> Spectrum<i class="checkbox-background" style="background-color: darkgreen;"></i></label></li>
              </ul>
            </dd>
            <!-- <dt>
              <label for="sample_count">Samples</label>
            </dt>
            <dd>
              <input class="input-field" type="range" name="samples" min="4" max="14" value="12" name="sample_count" id="sample_count" oninput="sample_count_out.value=Math.pow(2,this.valueAsNumber)">
            </dd>
            <dd class="output-field center">
              <output class="output-field" name="sample_count_out" for="sample_count">128</output>
            </dd> -->

            <dt>
              <label for="bandwidth">Bandwidth</label>
            </dt>
            <dd>
              <input class="input-field" type="range" name="samples" min="0" max="8" value="5" name="bandwidth" id="bandwidth" oninput="bandwidth_out.value=Math.pow(2,this.valueAsNumber)">
            </dd>
            <dd class="output-field center">
              <output class="output-field" name="bandwidth_out" for="bandwidth">128</output>
            </dd>

            <dt>
              <label for="generator">Amplitude (shape)</label>
            </dt>
            <dd style="grid-column: span 2;">
              <select class="input-field" name="generator" id="generator">
                <option value="gaus">Gau√ü</option>
                <option value="rect">Rectangle</option>
                <option value="constant">Constant</option>
                <option value="triangle">Triangle</option>
                <option value="cos">Cosine</option>
                <option value="dirac_pair">Dirac Pair</option>
                <option value="sha">Sha Train</option>
                <option value="exp">Exponential</option>
                <option value="saw">Saw</option>
              </select>
            </dd>
            <dt>
              <label for="amplitude">Amplitude (scale)</label>
            </dt>
            <dd style="grid-column: span 2;">
              <input class="input-field" type="range" step="0.1" name="amplitude" id="amplitude" min="0" max="5" value="1">
            </dd>

            <dt>
              <label for="phase_constant">Phase (constant)</label>
            </dt>
            <dd style="grid-column: span 2;">
              <input class="input-field" type="range" min="-0.5" max="0.5" step="0.0625" name="phase_constant" id="phase_constant" value="0">
            </dd>

            <dt>
              <label for="phase_linear">Phase (linear)</label>
            </dt>
            <dd style="grid-column: span 2;">
              <input class="input-field" type="range" min="-75" max="75" step="0.0625" name="phase_linear" id="phase_linear" value="0">
            </dd>

            <dt>
              <label for="frequency_shift">
                <span class="alttext" name="axislabel">
                  <span class="alt-a">Frequency</span><span class="placeholder">/</span><span class="alt-b">Time</span>
                </span>
               shift</label>
            </dt>
            <dd style="grid-column: span 2;">
              <input class="input-field" type="range" name="frequency_shift" id="frequency_shift" min="-0.25" max="0.25" step="0.01" value="0">
            </dd>
          </dl>

          <div id="slice-panel" class="control-panel-inner">
          <h2 style="grid-column: span 3;">Slicing</h2>

          <dl class="control-panel-inner">
            <dt>
              <label for="freq_slice_a">Frequency A</label>
            </dt>
            <dd>
              <input class="input-field" type="range" name="samples" min="-1024" max="1023" name="freq_slice_a" id="freq_slice_a" oninput="freq_slice_out_a.value=parseInt(this.valueAsNumber, 10)">
            </dd>
            <dd class="output-field">
              <output class="output-field" name="freq_slice_out_a" for="freq_slice_a">0</output>
            </dd>

            <dt>
              <label for="freq_slice_b">Frequency B</label>
            </dt>
            <dd>
              <input class="input-field" type="range" name="samples" min="-1024" max="1023" name="freq_slice_b" id="freq_slice_b" oninput="freq_slice_out_b.value=parseInt(this.valueAsNumber, 10)">
            </dd>
            <dd class="output-field">
              <output class="output-field" name="freq_slice_out_b" for="freq_slice_b">0</output>
            </dd>

            <dt>
              <label for="freq_slice_zoom">Zoom Slice<br> Amplitude</label>
            </dt>
            <dd>
              <input class="input-field" type="range" name="samples" min="1" max="20" step="0.1" value="1" name="freq_slice_zoom" id="freq_slice_zoom" oninput="freq_slice_out_zoom.value=parseInt(this.valueAsNumber, 10)">
            </dd>
            <dd class="output-field">
              <output class="output-field" name="freq_slice_out_zoom" for="freq_slice_zoom">1</output>
            </dd>
          </dl>
        </div>
        </form>
        </div>

      <div class="overlay camera-panel">
        <button style="float: right; margin: 0;width:auto;" class="button small" type="reset" onclick="viewFace(null)">Reset</button>

        <h2 class="overlay-head">Camera Controls</h2>
        <ul class="button-row">
          <li><button class="button big" onclick="viewFace(0)" style="--prim-color: #a00">s(t)</button></li>
          <li><button class="button big" onclick="viewFace(1)" style="--prim-color: #0a0">S(f)</button></li>
          <li><button class="button big" onclick="viewFace(2)" style="--prim-color: #0aa">s(-t)</button></li>
          <li><button class="button big" onclick="viewFace(3)" style="--prim-color: #a0a">S(-f)</button></li>
        </ul>
      </div>
      <div class="overlay view-panel">
        <form id="view-form" onsubmit="event.preventDefault()" oninput="document.getElementById('slice-panel').style.display=show_slices.checked?'contents':'none'">
        <button style="float: right; margin: 0;width:auto;" class="button small" type="reset" onclick="this.form.reset(); this.dispatchEvent(new Event('input',{bubbles:true})); event.preventDefault()">Reset</button>
        <h2 class="overlay-head">View Options</h2>
          <ul class="checkbox-row">
            <li><label class="checkbox-label"><input type="checkbox" checked id="show_shadows" name="show_shadows" value="1"> Shadows</label></li>
            <li><label class="checkbox-label"><input type="checkbox" checked id="show_axis" name="show_axis" value="1"> Axis</label></li>
            <li><label class="checkbox-label"><input type="checkbox" checked id="show_labels" name="show_labels" value="1"> Labels</label></li>
            <li><label class="checkbox-label"><input type="checkbox" id="show_slices" name="show_slices" value="1"> Slices</label></li>
            <li><label class="checkbox-label"><input type="checkbox" id="show_xray" name="show_xray" value="1"> X-Ray</label></li>
          </ul>
        </form>
      </div>
    </div>
    <div class="right">
      <div class="overlay">

        <details open>
          <summary>Show/Hide Introduction</summary>
        <h2>Fourier Cuboid</h2>

        <p>
          Explore the interrelation between the time domain of a signal and it's spectrum.
        </p>

        <p>
          The cuboid demonstrates the relationships between time and frequency domains. A 90 degree rotation of the cube represents a Fourier Transform. Taking the Fourier Transform twice results in the original signal flipped along the time axis. This corresponds to a 180 degree rotation i.e. viewing the signal from the backside. A third Fourier transform then results in the same spectrum as the first Fourier transform but flipped along the frequency axis. The fourth Fourier transform returns to the original signal.
        </p>

        <p>
          By viewing two neighboring sides of the cuboid at once you can introspect the relationship between the transformation of the signal in the time domain and it's spectrum in the frequency domain. For example shifting the signal along the time axis results in a linear phase rotation of the spectrum. A constant phase shift in one domain causes the same shift in the other domain. Stretching the signals causes the spectrum to contract and vice versa.
        </p>

        <p>
          You can chose to either model the signal and observe the resulting spectrum or to model the spectrum and observe the resulting signal.
        </p>

        <p>The transformation between time and frequency domain is done via Discrete Fourier Transform (DFT). This means that the signal and spectrum are both sampled discretely and not continuous as that would not be possible on a computer. Currently 2048 samples are used. Signals with frequencies higher than 1024/period may result in aliasing.</p>
        </details>
      </div>
    </div>
    <script src="regl.js"></script>
    <script>
            function transformMesh(key, mesh, fn) {
        return {
          ...mesh,
          [key]: {
            numComponents: mesh[key].numComponents,
            data: Array(mesh[key].data.length/mesh[key].numComponents).fill(null).flatMap((_,i) => {
              return fn(mesh[key].data.slice(i*mesh[key].numComponents, (i+1)*mesh[key].numComponents))
            })
          }
        }
      }

      function vectorMultiplyMatrix([x,y,z,w], matrix) {
        return [
          // wir verstehen ein Element mit 12 Elementen als 3x4 Matrix
          // ein 3D Punkt/Vektor mal eine 3x4 Matrix ergibt wieder einen Punkt
          /*neues X:*/ x * matrix[0] + y * matrix[1] + z * matrix[2] + matrix[3] * w,
          /*neues Y:*/ x * matrix[4] + y * matrix[5] + z * matrix[6] + matrix[7] * w,
          /*neues Z:*/ x * matrix[8] + y * matrix[9] + z * matrix[10] + matrix[11] * w,
          /*neues Z:*/ x * matrix[12] + y * matrix[13] + z * matrix[14] + matrix[15] * w,
        ]
      }

      function matrixMultiplyMatrix([
        _x1,  _x2,  _x3,  _x4,
        _y1,  _y2,  _y3,  _y4,
        _z1,  _z2,  _z3,  _z4,
        _w1,  _w2,  _w3,  _w4,
      ], [
        x1,  x2,  x3,  x4,
        y1,  y2,  y3,  y4,
        z1,  z2,  z3,  z4,
        w1,  w2,  w3,  w4,
      ]) {
        return [
          x1 * _x1 + x2 * _y1 + x3 * _z1 + x4 * _w1,
          x1 * _x2 + x2 * _y2 + x3 * _z2 + x4 * _w2,
          x1 * _x3 + x2 * _y3 + x3 * _z3 + x4 * _w3,
          x1 * _x4 + x2 * _y4 + x3 * _z4 + x4 * _w4,

          y1 * _x1 + y2 * _y1 + y3 * _z1 + y4 * _w1,
          y1 * _x2 + y2 * _y2 + y3 * _z2 + y4 * _w2,
          y1 * _x3 + y2 * _y3 + y3 * _z3 + y4 * _w3,
          y1 * _x4 + y2 * _y4 + y3 * _z4 + y4 * _w4,

          z1 * _x1 + z2 * _y1 + z3 * _z1 + z4 * _w1,
          z1 * _x2 + z2 * _y2 + z3 * _z2 + z4 * _w2,
          z1 * _x3 + z2 * _y3 + z3 * _z3 + z4 * _w3,
          z1 * _x4 + z2 * _y4 + z3 * _z4 + z4 * _w4,

          w1 * _x1 + w2 * _y1 + w3 * _z1 + w4 * _w1,
          w1 * _x2 + w2 * _y2 + w3 * _z2 + w4 * _w2,
          w1 * _x3 + w2 * _y3 + w3 * _z3 + w4 * _w3,
          w1 * _x4 + w2 * _y4 + w3 * _z4 + w4 * _w4,
        ]
      }

      function deg2rad(deg) {
        return deg/180 * Math.PI
      }

      function makeMatrixPerspective(fovDeg, aspect, near, far) {
        const f = 1.0 / Math.tan(deg2rad(fovDeg) / 2)
        const nf = 1 / (near - far)

        return [
          f / aspect, 0.0, 0.0, 0.0,
          0.0, f, 0.0, 0.0,
          0.0, 0.0, (far + near) * nf, -1.0,
          0.0, 0.0, (2 * far * near) * nf, 0.0
        ]
      }

      function makeMatrixIdentity() {
        return [
          1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          0, 0, 0, 1,
        ]
      }

      function makeMatrixScale(x,y,z) {
        return [
          x, 0, 0, 0,
          0, y, 0, 0,
          0, 0, z, 0,
          0, 0, 0, 1,
        ]
      }

      function makeMatrixTranslate(x,y,z) {
        return [
          1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          x, y, z, 1,
        ]
      }

      function makeMatrixRotateZ(angle) {
        const c = Math.cos(angle)
        const s = Math.sin(angle)
        return [
          c, -s, 0, 0,
          s,  c, 0, 0,
          0,  0, 1, 0,
          0,  0, 0, 1,
        ]
      }

      function makeMatrixRotateX(angle) {
        const c = Math.cos(angle)
        const s = Math.sin(angle)
        return [
          1, 0,  0, 0,
          0, c, -s, 0,
          0, s,  c, 0,
          0, 0,  0, 1,
        ]
      }

      function makeMatrixRotateY(angle) {
        const c = Math.cos(angle)
        const s = Math.sin(angle)
        return [
           c, 0, s,  0,
           0, 1, 0,  0,
          -s, 0, c,  0,
           0, 0, 0,  1,
        ]
      }

      function makeCubeBuffers(regl, w2, h2, d2) {
        return {
          vertices: regl.buffer([
            [-w2, +h2, +d2],
            [+w2, +h2, +d2],
            [+w2, -h2, +d2],
            [-w2, -h2, +d2], // positive z face.
            [+w2, +h2, +d2],
            [+w2, +h2, -d2],
            [+w2, -h2, -d2],
            [+w2, -h2, +d2], // positive x face
            [+w2, +h2, -d2],
            [-w2, +h2, -d2],
            [-w2, -h2, -d2],
            [+w2, -h2, -d2], // negative z face
            [-w2, +h2, -d2],
            [-w2, +h2, +d2],
            [-w2, -h2, +d2],
            [-w2, -h2, -d2], // negative x face.
            [-w2, +h2, -d2],
            [+w2, +h2, -d2],
            [+w2, +h2, +d2],
            [-w2, +h2, +d2], // top face
            [-w2, -h2, -d2],
            [+w2, -h2, -d2],
            [+w2, -h2, +d2],
            [-w2, -h2, +d2]  // bottom face
          ]),
          faceColors: regl.buffer([
            [1,0,0],
            [1,0,0],
            [1,0,0],
            [1,0,0], // positive z face.
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0], // positive x face
            [0,1,1],
            [0,1,1],
            [0,1,1],
            [0,1,1], // negative z face
            [1,0,1],
            [1,0,1],
            [1,0,1],
            [1,0,1], // negative x face.
            [1,1,0],
            [1,1,0],
            [1,1,0],
            [1,1,0], // top face
            [0,0,1],
            [0,0,1],
            [0,0,1],
            [0,0,1]
          ]),
          faceNormals: regl.buffer([
            [0,0,1],
            [0,0,1],
            [0,0,1],
            [0,0,1], // positive z face.
            [1,0,0],
            [1,0,0],
            [1,0,0],
            [1,0,0], // positive x face
            [0,0,-1],
            [0,0,-1],
            [0,0,-1],
            [0,0,-1], // negative z face
            [-1,0,0],
            [-1,0,0],
            [-1,0,0],
            [-1,0,0], // negative x face.
            [0,1,0],
            [0,1,0],
            [0,1,0],
            [0,1,0], // top face
            [0,-1,0],
            [0,-1,0],
            [0,-1,0],
            [0,-1,0]  // bottom face
          ]),
          uvCoords: regl.buffer([
            [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0], // positive z face.
            [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0], // positive x face.
            [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0], // negative z face.
            [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0], // negative x face.
            [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0], // top face
            [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]  // bottom face
          ]),
          elements: regl.elements([
            [2, 1, 0], [2, 0, 3],       // positive z face.
            [6, 5, 4], [6, 4, 7],       // positive x face.
            [10, 9, 8], [10, 8, 11],    // negative z face.
            [14, 13, 12], [14, 12, 15], // negative x face.
            [18, 17, 16], [18, 16, 19], // top face.
            [20, 21, 22], [23, 20, 22]  // bottom face
          ]),
          outline: regl.buffer([
            w2,h2,d2,
            -w2,h2,d2,
            -w2,h2,d2,
            -w2,-h2,d2,
            -w2,-h2,d2,
            w2,-h2,d2,
            w2,-h2,d2,
            w2,h2,d2,

            w2,h2,-d2,
            -w2,h2,-d2,
            -w2,h2,-d2,
            -w2,-h2,-d2,
            -w2,-h2,-d2,
            w2,-h2,-d2,
            w2,-h2,-d2,
            w2,h2,-d2,


            w2,h2,d2,
            w2,h2,-d2,
            -w2,h2,d2,
            -w2,h2,-d2,
            -w2,-h2,d2,
            -w2,-h2,-d2,
            w2,-h2,d2,
            w2,-h2,-d2
          ])
        }
      }

      function makeColorShader(regl) {
        return regl({
          frag: `
          precision mediump float;
          varying vec3 vColor;
          void main () {
            gl_FragColor = vec4(vColor,1);
          }`,
          vert: `
          precision mediump float;
          attribute vec3 position;
          attribute vec2 uvCoord;
          attribute vec3 faceColor;
          attribute vec3 faceNormal;
          varying vec3 vColor;
          uniform mat4 projection, view;
          void main() {
            vColor = faceColor;
            gl_Position = projection * view * vec4(position, 1);
          }`,
          attributes: {
            position: regl.prop('positions'),
            uvCoord: regl.prop('uvCoords'),
            faceColor: regl.prop('faceColors'),
            faceNormal: regl.prop('faceNormals'),
          },


          cull: {
            enable: true,
            face: 'back'
          },
          depth: {
            enable: false,
          },
          elements: regl.prop("elements"),
        })
      }

      function makeFaceStencilShader(regl) {
        return regl({
          frag: `
          precision mediump float;
          void main () {
            gl_FragColor = vec4(1,1,1,1);
          }`,
          vert: `
          attribute vec3 position;
          attribute vec3 faceColor;
          uniform mat4 projection, view;
          void main() {
            gl_Position = projection * view * vec4(position, 1);
          }`,
          attributes: {
            position: regl.prop('positions'),
            faceColor: regl.prop('faceColors'),
          },
          cull: {
            enable: true,
            face: 'back'
          },
          depth: {
            enable: false,
          },
          colorMask: [false, false, false, false],
          stencil: {
            enable: true,
            mask: (_, props) => 0x01 << props.stencilId,
            func: {
              cmp: 'always',
              ref: 0xff,
              mask: 0xff
            },
            op: {
              fail: 'keep',
              zfail: 'replace',
              zpass: 'replace'
            },
          },
          elements: regl.prop("elements"),
          count: 6,
          offset: (_,{face}) => face*6,
        })
      }

      function makeFaceShader(regl) {
        return regl({
          frag: `
          precision mediump float;
          varying float vDepth;
          void main () {
            gl_FragColor = vec4(1.0,1.0,0.5,vDepth);
          }`,
          vert: `
          attribute vec3 position;
          attribute vec3 faceColor;
          uniform vec3 axisShift;
          uniform mat4 projection, view;
          varying float vDepth;
          void main() {
            vDepth = dot(position, normalize(cross(axisShift, vec3(0,1,0))));
            gl_Position = projection * view * vec4(position+axisShift, 1);
          }`,
          attributes: {
            position: regl.prop('positions'),
            faceColor: regl.prop('faceColors'),
          },
          uniforms: {
            axisShift: regl.prop('axisShift'),
          },
          cull: {
            enable: false,
          },
          depth: {
            enable: false,
          },
          stencil: {
            enable: (_, props) => props.stencilId >= 0,
            func: {
              cmp: 'equal',
              ref: 0xff,
              mask: (_, props) => 1 << props.stencilId,
            },
            op: {
              fail: 'keep',
              zfail: 'keep',
              zpass: 'keep'
            },
          },
          blend: {
            enable: true,
            func: {
              srcRGB: 'src alpha',
              srcAlpha: 1,
              dstRGB: 'one minus src alpha',
              dstAlpha: 1
            },
            equation: {
              rgb: 'add',
              alpha: 'add'
            },
            color: [0, 0, 0, 0]
          },
          elements: regl.prop("elements"),
          count: 6,
          offset: (_,{face}) => face*6,
        })
      }

      function makeLightShader(regl) {
        return regl({
          frag: `
          precision mediump float;
          varying float vColor;
          void main () {
            gl_FragColor = vec4(vColor,vColor,vColor,0.5);
          }`,
          vert: `
          precision mediump float;
          attribute vec3 position;
          attribute vec2 uvCoord;
          attribute vec3 faceColor;
          attribute vec3 faceNormal;
          varying float vColor;
          uniform mat4 projection, view;
          void main() {
            vColor = dot(abs(faceNormal), vec3(0.3,0.1,0.7));
            gl_Position = projection * view * vec4(position, 1);
          }`,
          attributes: {
            position: regl.prop('positions'),
            uvCoord: regl.prop('uvCoords'),
            faceColor: regl.prop('faceColors'),
            faceNormal: regl.prop('faceNormals'),
          },
          cull: {
            enable: true,
            face: 'front'
          },
          depth: {
            enable: false,
          },
          blend: {
            enable: true,
            func: {
              srcRGB: 'src alpha',
              srcAlpha: 1,
              dstRGB: 'one minus src alpha',
              dstAlpha: 1
            },
            equation: {
              rgb: 'add',
              alpha: 'add'
            },
            color: [0, 0, 0, 0]
          },
          elements: regl.prop("elements"),
        })
      }

      function roundCapJoinGeometry(regl, resolution) {
        const instanceRoundRound = [
          [0, -0.5, 0],
          [0, -0.5, 1],
          [0, 0.5, 1],
          [0, -0.5, 0],
          [0, 0.5, 1],
          [0, 0.5, 0]
        ];
        // Add the left cap.
        for (let step = 0; step < resolution; step++) {
          const theta0 = Math.PI / 2 + ((step + 0) * Math.PI) / resolution;
          const theta1 = Math.PI / 2 + ((step + 1) * Math.PI) / resolution;
          instanceRoundRound.push([0, 0, 0]);
          instanceRoundRound.push([
            0.5 * Math.cos(theta0),
            0.5 * Math.sin(theta0),
            0
          ]);
          instanceRoundRound.push([
            0.5 * Math.cos(theta1),
            0.5 * Math.sin(theta1),
            0
          ]);
        }
        // Add the right cap.
        for (let step = 0; step < resolution; step++) {
          const theta0 = (3 * Math.PI) / 2 + ((step + 0) * Math.PI) / resolution;
          const theta1 = (3 * Math.PI) / 2 + ((step + 1) * Math.PI) / resolution;
          instanceRoundRound.push([0, 0, 1]);
          instanceRoundRound.push([
            0.5 * Math.cos(theta0),
            0.5 * Math.sin(theta0),
            1
          ]);
          instanceRoundRound.push([
            0.5 * Math.cos(theta1),
            0.5 * Math.sin(theta1),
            1
          ]);
        }
        return {
          buffer: regl.buffer(instanceRoundRound),
          count: instanceRoundRound.length
        };
      }

      function interleavedStripRoundCapJoin3D(regl, resolution) {
        roundCapJoin = roundCapJoinGeometry(regl, resolution);
        return regl({
          vert: `
            precision highp float;
            attribute vec3 position;
            attribute vec3 pointA, pointB;
            uniform float width;
            uniform vec2 resolution;
            uniform vec3 axisFilter;
            uniform vec3 axisShift;
            uniform mat4 model, view, projection;

            void main() {
              vec4 clip0 = projection * view * model * vec4(axisFilter*pointA + axisShift, 1.0);
              vec4 clip1 = projection * view * model * vec4(axisFilter*pointB + axisShift, 1.0);
              vec2 screen0 = resolution * (0.5 * clip0.xy/clip0.w + 0.5);
              vec2 screen1 = resolution * (0.5 * clip1.xy/clip1.w + 0.5);
              vec2 xBasis = normalize(screen1 - screen0);
              if(pointA==pointB) {
              	xBasis = vec2(1.0,0.0);
              }
              vec2 yBasis = vec2(-xBasis.y, xBasis.x);
              vec2 pt0 = screen0 + width * (position.x * xBasis + position.y * yBasis);
              vec2 pt1 = screen1 + width * (position.x * xBasis + position.y * yBasis);
              vec2 pt = mix(pt0, pt1, position.z);
              vec4 clip = mix(clip0, clip1, position.z);
              gl_Position = vec4(clip.w * (2.0 * pt/resolution - 1.0), clip.z, clip.w);
            }`,

          frag: `
            precision highp float;
            uniform vec4 color;
            void main() {
              gl_FragColor = color;
            }`,

          attributes: {
            position: {
              buffer: roundCapJoin.buffer,
              divisor: 0
            },
            pointA: {
              buffer: regl.prop("points"),
              divisor: 1,
              offset: (_, props) => ((props.segmentOffset??0) * 6 * Float32Array.BYTES_PER_ELEMENT) + Float32Array.BYTES_PER_ELEMENT * 0,
              stride: Float32Array.BYTES_PER_ELEMENT * 6
            },
            pointB: {
              buffer: regl.prop("points"),
              divisor: 1,
              offset: (_, props) => ((props.segmentOffset??0) * 6 * Float32Array.BYTES_PER_ELEMENT) + Float32Array.BYTES_PER_ELEMENT * 3 * (props.segmentLength??1),
              stride: Float32Array.BYTES_PER_ELEMENT * 6
            }
          },

          uniforms: {
            width: regl.prop("width"),
            axisFilter: regl.prop("axisFilter"),
            axisShift: regl.prop("axisShift"),
            color: regl.prop("color"),
            model: regl.prop("model"),
            resolution: regl.prop("resolution")
          },

          depth: {
            enable: regl.prop("depth")
          },

          cull: {
            enable: true,
            face: "back"
          },

          blend: {
            enable: true,
            func: {
              srcRGB: 'src alpha',
              srcAlpha: 1,
              dstRGB: 'one minus src alpha',
              dstAlpha: 1
            },
            equation: {
              rgb: 'add',
              alpha: 'add'
            },
            color: [0, 0, 0, 0]
          },

          stencil: {
            enable: (_, props) => props.stencilId >= 0,
            func: {
              cmp: 'equal',
              ref: 0xff,
              mask: (_, props) => 1 << props.stencilId,
            },
            op: {
              fail: 'keep',
              zfail: 'keep',
              zpass: 'keep'
            },
          },

          count: roundCapJoin.count,
          instances: regl.prop("segments")
        });
      }

      function arrowShader(regl) {
        var roundCapJoin = {
          buffer: regl.buffer([
            [0, -0.5, 0],
            [0, -0.5, 1],
            [0, 0.5, 1],
            [0, -0.5, 0],
            [0, 0.5, 1],
            [0, 0.5, 0],

            [8,0,1],
            [0.5,3,1],
            [2,0,1],

            [8,0,1],
            [2,0,1],
            [0.5,-3,1],
          ]),
          count: 12
        }

        return regl({
          vert: `
            precision highp float;
            attribute vec3 position;
            attribute vec3 pointA, pointB;
            uniform float width;
            uniform vec2 resolution;
            uniform mat4 model, view, projection;

            void main() {
              vec4 clip0 = projection * view * model * vec4(pointA, 1.0);
              vec4 clip1 = projection * view * model * vec4(pointB, 1.0);
              vec2 screen0 = resolution * (0.5 * clip0.xy/clip0.w + 0.5);
              vec2 screen1 = resolution * (0.5 * clip1.xy/clip1.w + 0.5);
              vec2 xBasis = normalize(screen1 - screen0);
              vec2 yBasis = vec2(-xBasis.y, xBasis.x);
              vec2 pt0 = screen0 + width * (position.x * xBasis + position.y * yBasis);
              vec2 pt1 = screen1 + width * (position.x * xBasis + position.y * yBasis);
              vec2 pt = mix(pt0, pt1, position.z);
              vec4 clip = mix(clip0, clip1, position.z);
              gl_Position = vec4(clip.w * (2.0 * pt/resolution - 1.0), clip.z, clip.w);
            }`,

          frag: `
            precision highp float;
            uniform vec4 color;
            void main() {
              gl_FragColor = color;
            }`,

          attributes: {
            position: {
              buffer: roundCapJoin.buffer,
              divisor: 0
            },
            pointA: {
              buffer: regl.prop("points"),
              divisor: 1,
              offset: Float32Array.BYTES_PER_ELEMENT * 0,
              stride: Float32Array.BYTES_PER_ELEMENT * 6
            },
            pointB: {
              buffer: regl.prop("points"),
              divisor: 1,
              offset: Float32Array.BYTES_PER_ELEMENT * 3,
              stride: Float32Array.BYTES_PER_ELEMENT * 6
            }
          },

          uniforms: {
            width: regl.prop("width"),
            color: regl.prop("color"),
            model: regl.prop("model"),
            resolution: regl.prop("resolution")
          },

          depth: {
            enable: regl.prop("depth")
          },

          cull: {
            enable: true,
            face: "back"
          },

          blend: {
            enable: true,
            func: {
              srcRGB: 'src alpha',
              srcAlpha: 1,
              dstRGB: 'one minus src alpha',
              dstAlpha: 1
            },
            equation: {
              rgb: 'add',
              alpha: 'add'
            },
            color: [0, 0, 0, 0]
          },

          stencil: {
            enable: (_, props) => props.stencilId >= 0,
            func: {
              cmp: 'equal',
              ref: 0xff,
              mask: (_, props) => 1 << props.stencilId,
            },
            op: {
              fail: 'keep',
              zfail: 'keep',
              zpass: 'keep'
            },
          },

          polygonOffset: {
            enable: true,
            offset: {
              factor: 0,
              units: 32
            }
          },


          count: roundCapJoin.count,
          instances: regl.prop("segments")
        });
      }

      function labelShader(regl) {
        var quad = regl.buffer([
          [-0.5, -0.5],
          [0.5, -0.5],
          [0.5, 0.5],

          [0.5, 0.5],
          [-0.5, -0.5],
          [-0.5, 0.5],
        ])

        return regl({
          vert: `
            precision highp float;
            attribute vec2 position;
            attribute vec3 point;
            attribute vec2 glyphCoord;
            uniform float width;
            uniform vec2 resolution;
            uniform vec2 offset;
            uniform mat4 model, view, projection;
            uniform sampler2D  atlas;

            varying vec2 vGlyph;
            varying vec2 vPos;

            void main() {
              vec4 center = projection * view * model * vec4(point, 1.0);
              vec2 screen = resolution * (0.5 * center.xy/center.w + 0.5);
              vec2 pt = screen + width * (position + offset);

              vGlyph = 0.5*glyphCoord + 0.5*(position * vec2(1.0,-1.0) + 0.5);
              gl_Position = vec4(center.w * (2.0 * pt/resolution - 1.0), center.z, center.w);
            }`,

          frag: `
            precision highp float;
            uniform vec4 color;
            varying vec2 vGlyph;
            uniform sampler2D atlas;

            void main() {
              gl_FragColor = color * texture2D(atlas, vGlyph);
            }`,

          attributes: {
            position: {
              buffer: quad,
              divisor: 0
            },
            point: {
              buffer: regl.prop("points"),
              divisor: 1,
              offset: Float32Array.BYTES_PER_ELEMENT * 0,
              stride: Float32Array.BYTES_PER_ELEMENT * 3
            },
            glyphCoord: {
              buffer: regl.prop("glyphs"),
              divisor: 1,
              offset: Float32Array.BYTES_PER_ELEMENT * 0,
              stride: Float32Array.BYTES_PER_ELEMENT * 2
            },
          },

          uniforms: {
            width: regl.prop("width"),
            color: regl.prop("color"),
            model: regl.prop("model"),
            point: regl.prop("point"),
            resolution: regl.prop("resolution"),
            atlas: regl.prop("atlas"),
            offset: regl.prop("offset"),
          },

          depth: {
            enable: false
          },

          cull: {
            enable: false,
            face: "back"
          },

          blend: {
            enable: true,
            func: {
              srcRGB: 'src alpha',
              srcAlpha: 1,
              dstRGB: 'one minus src alpha',
              dstAlpha: 1
            },
            equation: {
              rgb: 'add',
              alpha: 'add'
            },
            color: [0, 0, 0, 0]
          },

          stencil: {
            enable: (_, props) => props.stencilId >= 0,
            func: {
              cmp: 'equal',
              ref: 0xff,
              mask: (_, props) => 1 << props.stencilId,
            },
            op: {
              fail: 'keep',
              zfail: 'keep',
              zpass: 'keep'
            },
          },

          polygonOffset: {
            enable: true,
            offset: {
              factor: 0,
              units: 60
            }
          },

          count: 6,
          instances: regl.prop("segments"),
        });
      }

      function makeDragControl(regl, el) {
        const state = {
          isDragging: false,
          zoom: 1,
          rotationX: 0.26,
          rotationY: -0.84,
          isTouching: false,
          touchX: 0,
          touchY: 0,
          setup: regl({
            context: {
              view: ({tick}) => {
                const w = el.width/2
                const t = 0.01 * tick
                return [
                  makeMatrixTranslate(0,0,-24+8*state.zoom),
                  makeMatrixRotateX(-state.rotationX),
                  makeMatrixRotateY(-state.rotationY),
                  makeMatrixScale(8,8, 8),
                ].reduce(matrixMultiplyMatrix)
              },
              projection: ({viewportWidth, viewportHeight}) =>
                makeMatrixPerspective(60, viewportWidth/viewportHeight, 0.01, 128),

              viewport: () => ({ x: 0, y: 0, width: el.width, height: el.height }),
            },

            uniforms: {
              view: regl.context('view'),
              projection: regl.context('projection'),
              viewport: regl.context('viewport'),
            }
          }),
        }

        function pan(dx, dy) {
          state.rotationX += 0.01 * dy * window.devicePixelRatio
          state.rotationY += 0.01 * dx * window.devicePixelRatio

          state.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, state.rotationX))
        }

        function zoom(z) {
          state.zoom *= Math.pow(2, z)
          state.zoom = Math.max(0.5, Math.min(2, state.zoom))
        }

        el.addEventListener('mousedown', function(evt) {
          evt.preventDefault()
          state.isDragging = true
        })

        el.ownerDocument.addEventListener('mousemove', function(evt) {
          if(state.isDragging) {
            pan(evt.movementX, evt.movementY)
          }
        })

        el.ownerDocument.addEventListener('mouseup', function() {
          state.isDragging = false
        })

        el.addEventListener('wheel', function(evt) {
          if(evt.shiftKey || evt.altKey) {
            return
          }
          evt.preventDefault()
          zoom(evt.wheelDelta/400)
        })

        var touchState = {
          touchIds: [],
          prevDistance: null,
          prevRotation: null,
        }

        el.addEventListener('touchstart', function touchStart(evt) {
          var newIds = Array.prototype.map.call(evt.changedTouches, function(t) {
            return t.identifier;
          })

          touchState.touchIds = touchState.touchIds.concat(newIds).filter(onlyUnique)

          var touches = filterTouches(touchState.touchIds, evt.touches)

          if(touchState.touchIds.length >= 1) {
            touchState.panBase = touchCenter(touches)
          } else {
            touchState.panBase = null
          }

          if (touchState.touchIds.length >= 1) {
            touchState.prevDistance = touchRadius(touches);
            touchState.prevRotation = touchRotation(touches);
            touchState.pinchPivot = touchCenter(touches)
          } else {
            touchState.prevDistance = null;
            touchState.prevRotation = null;
          }

          if(evt.touches.length >= 1) {
            event.preventDefault()
          }
        });

        el.ownerDocument.addEventListener('touchmove', function touchMove(evt) {
          if(touchState.touchIds.length === 0) {
            return;
          }

          var touches = filterTouches(touchState.touchIds, evt.touches)
          var preventDefault = false;

          if(touchState.panBase) {
            var pos = touchCenter(touches)
            pan((pos.x - touchState.panBase.x)/3, (pos.y - touchState.panBase.y)/3)
            touchState.panBase.x = pos.x
            touchState.panBase.y = pos.y
            preventDefault = true;
          }

          if(touchState.prevDistance) {
            var touches = filterTouches(touchState.touchIds, evt.touches)
            var distance = touchRadius(touches);

            zoom((distance - touchState.prevDistance) / 100, touchState.pinchPivot);
            touchState.prevDistance = distance;
            preventDefault = true;
          }

          if(touches.length >= 2) {
            var rotation = touchRotation(touches)
            if(rotation && touchState.prevRotation !== null) {
              rotate(pos, ((rotation - touchState.prevRotation + 360 + 180) % 360 - 180) / touches.length)
              touchState.prevRotation = rotation;
            } else if(rotation) {
              touchState.prevRotation = rotation;
            }
            preventDefault = true;
          }

          if(false && preventDefault) {
            evt.preventDefault()
          }
        });

        el.ownerDocument.addEventListener('touchend', function touchEnd(evt) {
          if(touchState.touchIds.length === 0) {
            return
          }
          var oldIds = Array.prototype.map.call(evt.changedTouches, function(t) {
            return t.identifier;
          })

          touchState.touchIds = touchState.touchIds.filter(function diffId(id) {
            return oldIds.indexOf(id) < 0;
          })

          var touches = filterTouches(touchState.touchIds, evt.touches)

          if(touchState.touchIds.length >= 2) {
            touchState.panBase = touchCenter(touches)
          } else {
            touchState.panBase = null
          }

          if(touchState.touchIds.length >= 2) {
            touchState.prevDistance = touchRadius(touches);
            touchState.prevRotation = null;
            touchState.pinchPivot = touchCenter(touches)
          } else {
            touchState.prevDistance = null;
            touchState.prevRotation = null;
          }
        });

        function touchCenter(touches) {
          var length = touches.length
          return Array.prototype.reduce.call(touches, function(sum, touch) {
            return {
              x: sum.x + touch.clientX / length,
              y: sum.y + touch.clientY / length,
            };
          }, {x: 0, y: 0});
        }

        function touchRadius (touches) {
          var length = touches.length
          var center = touchCenter(touches)

          return Array.prototype.reduce.call(touches, function(sum, touch) {
              return sum +
              Math.sqrt(
                Math.pow(touch.clientX - center.x, 2) +
                Math.pow(touch.clientY - center.y, 2)
              );
          }, 0) / length
        }

        function touchRotation(touches) {
          var center = touchCenter(touches)

          var angles = Array.prototype.map.call(touches, function(touch) {
            return Math.atan2(touch.clientY - center.y, touch.clientX - center.x) + Math.PI;
          }, 0);

          var sum = (Array.prototype.reduce.call(angles, function(a,b){
            return a + b;
          }) * 180 / Math.PI);

          return (sum + 360 % 360);
        }


        function filterTouches (ids, touches) {
          return Array.prototype.filter.call(touches, function(t) {
            return ids.indexOf(t.identifier) > -1;
          })
        }

        function onlyUnique(value, index, self) {
          return self.indexOf(value) === index;
        }

        return state
      }


      const shadowCheckbox = document.getElementById('show_shadows');
      const labelCheckbox = document.getElementById('show_labels');
      const axisCheckbox = document.getElementById('show_axis');
      const slicesCheckbox = document.getElementById('show_slices');
      const xrayCheckbox = document.getElementById('show_xray');

      const canvas = document.getElementById("c")
      var gl = c.getContext('webgl', {
        antialias: true,
        stencil: true
      })

      var regl = createREGL({
        canvas,
        extensions: ["ANGLE_instanced_arrays"],
      })

      let freqSliceA = 0
      let freqSliceB = 0

      var camera = makeDragControl(regl, canvas)
      var cubeMesh = makeCubeBuffers(regl, 0.5, 0.25, 0.5)
      var drawColor = makeColorShader(regl)
      var drawStencilFace = makeFaceStencilShader(regl)
      var drawFace = makeFaceShader(regl)
      var drawLight = makeLightShader(regl)
      var drawLine3D = interleavedStripRoundCapJoin3D(regl, 4)
      var drawArrow3D = arrowShader(regl)
      var drawLabel = labelShader(regl)

      function viewFace(face) {
        if(face === null) {
          camera.rotationX = 0.26
          camera.rotationY = -0.84
        } else {
          camera.rotationX = 0
          camera.rotationY = -Math.PI/2 * face
        }
      }

      const arrowBuffer = regl.buffer([
        //x
        -0.45,0,0,
        0.45,0,0,

        //z
        0,0,-0.2,
        0,0,0.2,

        //y
        0,-0.2,0,
        0,0.2,0,

      ]);

      const labelBuffer = regl.buffer([
        0.45,0.0,0.0,
        0.0,0.0,0.20,
        0.0,0.20,0.0,
        0.45,0.0,0.0,
      ])
      const glyphBuffer = regl.buffer([
        1,1,
        1,0,
        0,0,
      ])
      const glyphBuffer2 = regl.buffer([
        0,1,
        1,0,
        0,0,
      ])

      const textureCanvas = document.createElement('canvas')
      textureCanvas.width = 256
      textureCanvas.height = 256
      const context2D = textureCanvas.getContext('2d')
      context2D.fillStyle = 'red'
      context2D.font = "100px sans-serif";
      context2D.fontWeight = "bold";
      context2D.fillStyle = 'white';
      context2D.textAlign = "center";
      context2D.textBaseline = "middle";
      context2D.fillText("Re", 64,64)
      context2D.fillText("Im", 192,64)
      context2D.fillText("t", 64,192)
      context2D.fillText("f", 192,192)
      const glypthTexture = regl.texture(textureCanvas)

      const textureCanvas2 = document.createElement('canvas')
      textureCanvas2.width = 1024
      textureCanvas2.height = 1024
      const context2D2 = textureCanvas2.getContext('2d')
      context2D2.fillStyle = 'red'
      context2D2.font = "230px sans-serif";
      context2D2.fontWeight = "bold";
      context2D2.fillStyle = 'white';
      context2D2.textAlign = "center";
      context2D2.textBaseline = "middle";
      context2D2.fillText("s(t)", 256,256)
      context2D2.fillText("S(f)", 512+256,256)
      context2D2.fillText("s(-t)", 256,512+256)
      context2D2.fillText("S(-f)", 512+256,512+256)
      const glypthTexture2 = regl.texture(textureCanvas2)

      let sampleSize = 2048
      let samples = Array(sampleSize).fill(null).map((_,i) => i)

      const signalBuffer = regl.buffer(sampleSize);
      const spectrumBuffer = regl.buffer(sampleSize);
      const sliceABuffer = regl.buffer(sampleSize);
      const sliceBBuffer = regl.buffer(sampleSize);

      function _fft(amplitudes) {
          var N = amplitudes.length

          if(N <= 1){
              return amplitudes
          }

          var hN = N / 2;

          var even = Array(hN).fill(null)
          var odd = Array(hN).fill(null)

          for(var i = 0; i < hN; ++i){
              even[i] = amplitudes[i*2]
              odd[i] = amplitudes[i*2+1]
          }

          even = _fft(even)
          odd = _fft(odd)

          var a = -2*Math.PI

          for(var k = 0; k < hN; ++k){
              var p = k/N;
              var t = [Math.cos(a*p), Math.sin(a*p)];

              var r = t[0] * odd[k][0] - t[1] * odd[k][1];
              t[1] = t[0] * odd[k][1] + t[1] * odd[k][0];
              t[0] = r;

              amplitudes[k] = [  even[k][0] + t[0],  even[k][1] + t[1]];
              amplitudes[k + hN] = [  even[k][0] - t[0],   even[k][1] - t[1]];
          }


          return amplitudes;
      }

      function fftShift(values) {
          return values.map((_,i) => values[(i + values.length/2) % values.length])
      }

      function fftAddPadding(factor, values) {
        return [
          ...values.slice(0, values.length/2), 
          ...Array(values.length*(Math.pow(2,factor)-1)).fill([0,0]),
          ...values.slice(values.length/2)
        ]
      }

      function fftRemovePadding(factor, values) {
        const realLength = values.length / Math.pow(2,factor)
        return [
          ...values.slice(0, realLength/2),
          ...values.slice(-realLength/2)
        ]
      }

      function fft(amplitudes)
      {
          var N = amplitudes.length;
          var iN = 1 / N;

          // Apply Fourier Transform
          amplitudes = _fft(amplitudes)

          for(i = 0; i < N; ++i){
              amplitudes[i][0] *= Math.sqrt(iN/2)
              amplitudes[i][1] *= Math.sqrt(iN/2)
          }
          return amplitudes;
      }

      function fftInverse(amplitudes)
      {
          N = amplitudes.length;
          iN = 1 / N;

          // Conjugate if imaginary part is not 0
          for(i = 0; i < N; ++i){
              amplitudes[i][1] = -amplitudes[i][1]
          }

          // Apply Fourier Transform
          amplitudes = _fft(amplitudes)

          for(i = 0; i < N; ++i){
              //Conjugate again
              amplitudes[i][1] = -amplitudes[i][1]
              // Scale
              amplitudes[i][0] *= Math.sqrt(iN/2)
              amplitudes[i][1] *= Math.sqrt(iN/2)
          }
          return amplitudes;
      }

      const generators = {
        gaus: (f, bandwidth) =>
        Math.exp(-(f*f)/4/bandwidth/bandwidth)/Math.sqrt(bandwidth)/Math.sqrt(2*Math.PI),
        rect: (f, bandwidth) =>
        (Math.abs(f/Math.PI) < bandwidth) /Math.sqrt(bandwidth)/Math.sqrt(2*Math.PI)/2,
        constant: (f, bandwidth) =>
        1 / sampleSize * 8,
        triangle: (f, bandwidth) =>
        2*Math.max((bandwidth-Math.abs(f/Math.PI)), 0)/bandwidth /Math.sqrt(bandwidth)/Math.sqrt(2*Math.PI)/2,
        sinc: (f, bandwidth) => (f==0? 1 :
        Math.sin(f/bandwidth*Math.PI/2)/(f/bandwidth*Math.PI/2))/Math.sqrt(2*Math.PI)/Math.sqrt(bandwidth),
        cos: (f, bandwidth) => Math.cos(f/bandwidth/4*Math.PI*2)/(16*Math.PI),
        dirac_pair: (f, bandwidth) => (Math.abs(f)+1==bandwidth ? 1 : 0)/2,
        sha: (f, bandwidth) => f%bandwidth===0 ? 16*Math.sqrt(bandwidth)/sampleSize : 0,
        exp: (f, bandwidth) => 1/(Math.pow(2, Math.abs(f/bandwidth)))/Math.sqrt(Math.PI)/Math.sqrt(bandwidth),
        saw: (f, bandwidth) => (((f%(bandwidth*2)+(bandwidth*2))%(bandwidth*2)-bandwidth)/bandwidth/16/Math.sqrt(2*Math.PI)),
      }

      function loadSpectrum(sampleCount, domain, type, amplitude, phaseC, phaseL, freqShift, bandwidth, sliceA, sliceB, sliceZoom) {
        sampleSize = sampleCount
        samples = Array(sampleSize).fill(null).map((_,i) => i)

        const paddingFactor = 0
        const freqSliceA_ = ((sliceA%sampleSize) + sampleSize*1.5
) % (sampleSize) - sampleSize/2
        const freqSliceB_ = ((sliceB%sampleSize) + sampleSize*1.5
) % (sampleSize) - sampleSize/2
        freqSliceA = Math.min(freqSliceA_, freqSliceB_)
        freqSliceB = Math.max(freqSliceA_, freqSliceB_)

        const inputDomain = samples.map((x) => {
          //const f = ((x+freqShift+sampleSize)%(sampleSize))-sampleSize/2
          const f = (x+freqShift*sampleSize)-sampleSize/2

          const mag = generators[type](f, bandwidth)

          return [
            (x-sampleSize/2)/sampleSize* 0.9,

            mag * amplitude * Math.cos((phaseL*f/sampleSize + phaseC) * Math.PI * 4),

            mag * amplitude * Math.sin((phaseL*f/sampleSize + phaseC)* Math.PI * 4),
          ]
        })

        const transform = {spectrum: fftInverse, signal: fft}[domain]
        const outputDomain = fftShift(fftRemovePadding(paddingFactor, transform(fftAddPadding(paddingFactor, fftShift(inputDomain).map(([_,re,im]) => [re, im]))))).map(([re,im], i) => [inputDomain[i][0], re, im])

        const origin = inputDomain.flatMap(([x,y,z]) => [x,y,z,x,y,z]).slice(3)
        const target = outputDomain.flatMap(([x,y,z]) => [x,y,z,x,y,z]).slice(3)

        const signalArray = domain === 'signal' ? origin : target
        const spectrumArray = domain === 'spectrum' ? origin : target

        signalBuffer(signalArray)
        spectrumBuffer(spectrumArray)

        const spec = domain === 'signal' ? outputDomain : inputDomain

        const sliceDomainA = samples.map((x) => {
          const f = x-sampleSize/2

          const mag = Math.sqrt(spec[sampleSize/2 + freqSliceA][1]*spec[sampleSize/2 + freqSliceA][1] + spec[sampleSize/2 + freqSliceA][2] * spec[sampleSize/2 + freqSliceA][2])

          const phase = Math.atan2(spec[sampleSize/2 + freqSliceA][2], spec[sampleSize/2 + freqSliceA][1])

          return [
            sliceZoom * (x-sampleSize/2)/sampleSize* 0.9,

            sliceZoom * mag * 2 / Math.sqrt(sampleSize) * Math.cos((freqSliceA*f/sampleSize) * Math.PI * 2 + phase),

            sliceZoom * mag * 2 / Math.sqrt(sampleSize) * Math.sin((freqSliceA*f/sampleSize)* Math.PI * 2 + phase),
          ]
        })

        const sliceDomainB = samples.map((x) => {
          const f = x-sampleSize/2

          const mag = Math.sqrt(
            spec[sampleSize/2 + freqSliceB][1]*spec[sampleSize/2 + freqSliceB][1]
            +
            spec[sampleSize/2 + freqSliceB][2]*spec[sampleSize/2 + freqSliceB][2])

          const phase = Math.atan2(spec[sampleSize/2 + freqSliceB][2], spec[sampleSize/2 + freqSliceB][1])

          return [
            sliceZoom * (x-sampleSize/2)/sampleSize* 0.9,

            sliceZoom * mag * 2 / Math.sqrt(sampleSize) * Math.cos((freqSliceB*f/sampleSize) * Math.PI * 2 + phase),

            sliceZoom * mag * 2 / Math.sqrt(sampleSize) * Math.sin((freqSliceB*f/sampleSize)* Math.PI * 2 + phase),
          ]
        })

        sliceABuffer(sliceDomainA.flatMap(([x,y,z]) => [x,y,z,x,y,z]).slice(3))
        sliceBBuffer(sliceDomainB.flatMap(([x,y,z]) => [x,y,z,x,y,z]).slice(3))
      }

      document.getElementById('spectrum-form').bandwidth.dispatchEvent(new Event("input", {bubbles: true}))
      document.getElementById('view-form').show_slices.dispatchEvent(new Event("input", {bubbles: true}))

      canvas.width = canvas.clientWidth * window.devicePixelRatio
      canvas.height = canvas.clientHeight * window.devicePixelRatio

      const identity = makeMatrixIdentity()
      const rotationMatricesAxis = Array(6).fill(null).map((_,s) => [
        makeMatrixRotateY(-Math.PI*2 * s/4),
        makeMatrixTranslate(0,0,0.25),
      ].reduce(matrixMultiplyMatrix))

      const rotationMatricesAxisFlipped = Array(6).fill(null).map((_,s) => [
        makeMatrixRotateY(-Math.PI*2 * s/4),
        makeMatrixTranslate(0,0,0.25),
        makeMatrixScale(s>1?-1:1,1,s>1?-1:1),
      ].reduce(matrixMultiplyMatrix))

      const rotationMatricesAxisNoCube = Array(6).fill(null).map((_,s) => [
        makeMatrixRotateY(-Math.PI*2 * s/4),
        makeMatrixTranslate(0,0,0.5),
      ].reduce(matrixMultiplyMatrix))

      const rotationMatricesAxisNoCubeFlipped = Array(6).fill(null).map((_,s) => [
        makeMatrixRotateY(-Math.PI*2 * s/4),
        makeMatrixTranslate(0,0,0.5),
        makeMatrixScale(s>1?-1:1,1,s>1?-1:1),
      ].reduce(matrixMultiplyMatrix))

      const matrixA = makeMatrixTranslate(0,0,0.25)
      const matrixB = makeMatrixTranslate(0,0,-0.25)
      const matrixANoCube = makeMatrixTranslate(0,0.7,0.3)
      const matrixBNoCube = makeMatrixTranslate(0,0.7,-0.3)

      regl.frame(function () {

        canvas.width = canvas.clientWidth * window.devicePixelRatio
        canvas.height = canvas.clientHeight * window.devicePixelRatio

        regl.clear({
          color: [0.96, 0.96, 0.96, 1],
          stencil: 0
        })
        camera.setup(() => {
          if(!xrayCheckbox.checked) {
            drawColor({
              positions: cubeMesh.vertices,
              uvCoords: cubeMesh.uvCoords,
              faceColors: cubeMesh.faceColors,
              faceNormals: cubeMesh.faceNormals,
              elements: cubeMesh.elements,
              cullFace: 'front',
            })
            drawLight({
              positions: cubeMesh.vertices,
              uvCoords: cubeMesh.uvCoords,
              faceColors: cubeMesh.faceColors,
              faceNormals: cubeMesh.faceNormals,
              elements: cubeMesh.elements,
              cullFace: 'back',
            })
            drawLine3D({
              points: cubeMesh.outline,
              model: identity,
              axisFilter: [1,1,1],
              axisShift: [0,0,0],
              color: [0, 0, 0, 1],
              width: 1 * window.devicePixelRatio,
              segments: 12,
              resolution: [canvas.width,canvas.height],
              depth: true,
            })



            for(let s=0;s<6;s++) {
              drawStencilFace({
                positions: cubeMesh.vertices,
                uvCoords: cubeMesh.uvCoords,
                faceColors: cubeMesh.faceColors,
                faceNormals: cubeMesh.faceNormals,
                elements: cubeMesh.elements,
                cullFace: 'front',
                face: s,
                stencilId: s,
              })
            }

            for(let s=0;s<4;s++) {
              if(shadowCheckbox.checked) {
                drawLine3D({
                  points: s%2?spectrumBuffer:signalBuffer,
                  axisFilter: [0,1,1],
                  axisShift: [(s<2?1:-1)*-0.5,0,s>1?-0.5:0],
                  model: rotationMatricesAxisFlipped[s%2],
                  color: [0,0,0,0.3],
                  width: 2 * window.devicePixelRatio,
                  segments: samples.length-1,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                  stencilId: s,
                })

                drawLine3D({
                  points: s%2?spectrumBuffer:signalBuffer,
                  axisFilter: [1,0,1],
                  axisShift: [0,-0.25,s>1?-0.5:0],
                  model: rotationMatricesAxisFlipped[s%2],
                  color: [0,0,0,0.5],
                  width: 2 * window.devicePixelRatio,
                  segments: samples.length-1,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                  stencilId: s,
                })

                drawLine3D({
                  points: s%2?spectrumBuffer:signalBuffer,
                  axisFilter: [1,1,0],
                  axisShift: [0,0,(s<2?-0.75:0.25)],
                  model: rotationMatricesAxisFlipped[s%2],
                  color: [0,0,0,0.5],
                  width: 2 * window.devicePixelRatio,
                  segments: samples.length-1,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                  stencilId: s,
                })
              }


              drawLine3D({
                points: s%2?spectrumBuffer:signalBuffer,
                axisFilter: [1,1,1],
                axisShift: [0,0,0],
                model: rotationMatricesAxisFlipped[s],
                color: [1,1,1, 1],
                width: 2 * window.devicePixelRatio,
                segments: samples.length-1,
                resolution: [canvas.width,canvas.height],
                depth: true,
                stencilId: s,
              })

              if(axisCheckbox.checked) {

                drawArrow3D({
                  points: arrowBuffer,
                  model: rotationMatricesAxis[s],
                  color: [0,0,0, 1],
                  width: 2 * window.devicePixelRatio,
                  segments: s !=4 ? 3 : 2,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                  stencilId: s,
                })
              }

              if(labelCheckbox.checked) {
                if(axisCheckbox.checked) {
                  drawLabel({
                    points: labelBuffer,
                    glyphs: s%2 ? glyphBuffer : glyphBuffer2,
                    atlas: glypthTexture,
                    offset: [0.5,0.5],
                    model: rotationMatricesAxis[s],
                    color: [0,0,0, 1],
                    width: 30 * window.devicePixelRatio,
                    resolution: [canvas.width,canvas.height],
                    depth: false,
                    segments: 3,
                    stencilId: s,
                  })
                }

                drawLabel({
                  points: [0,-0.2,0],
                  glyphs: [s%2,s>1?1:0],
                  atlas: glypthTexture2,
                  offset: [0,0],
                  model: rotationMatricesAxis[s],
                  color: [1,1,1, 0.4],
                  width: 100 * window.devicePixelRatio,
                  resolution: [canvas.width,canvas.height],
                  depth: false,
                  segments: 1,
                  stencilId: s,
                })
              }

              if(slicesCheckbox.checked) {
                if(s===1 || s===3) {
                  drawFace({
                    positions: cubeMesh.vertices,
                    uvCoords: cubeMesh.uvCoords,
                    faceColors: cubeMesh.faceColors,
                    faceNormals: cubeMesh.faceNormals,
                    elements: cubeMesh.elements,
                    face: (s+3)%4,
                    stencilId: s,
                    axisShift: [
                      0,
                      0,(0.45*-freqSliceA/(sampleSize/2) + -(s==3?-1:1)*0.5),
                    ],
                  })
                  drawFace({
                    positions: cubeMesh.vertices,
                    uvCoords: cubeMesh.uvCoords,
                    faceColors: cubeMesh.faceColors,
                    faceNormals: cubeMesh.faceNormals,
                    elements: cubeMesh.elements,
                    face: (s+3)%4,
                    stencilId: s,
                    axisShift: [
                      0,
                      0,(0.45*-freqSliceB/(sampleSize/2) + -(s==3?-1:1)*0.5),
                    ],
                  })

  		            drawLine3D({
  		              points: s%2?spectrumBuffer:signalBuffer,
  		              axisFilter: [1,1,1],
  		              axisShift: [0,0,0],
  		              model: rotationMatricesAxisFlipped[s],
  		              color: [1,1,0.5, 0.8],
  		              width: 7 * window.devicePixelRatio,
  		              segments: 1,
  		              segmentOffset: Math.min(sampleSize-9, freqSliceB + sampleSize/2),
  		              segmentLength: 0,
  		              resolution: [canvas.width,canvas.height],
  		              depth: false,
  		              stencilId: s,
  		            })

  		            drawLine3D({
  		              points: s%2?spectrumBuffer:signalBuffer,
  		              axisFilter: [1,1,1],
  		              axisShift: [0,0,0],
  		              model: rotationMatricesAxisFlipped[s],
  		              color: [1,1,0.5, 0.8],
  		              width: 7 * window.devicePixelRatio,
  		              segments: 1,
  		              segmentOffset: Math.min(sampleSize-9, freqSliceA + sampleSize/2),
  		              segmentLength: 0,
  		              resolution: [canvas.width,canvas.height],
  		              depth: false,
  		              stencilId: s,
  		            })
                }

                // if(s===2) {
                //  drawFace({
                  //   positions: cubeMesh.vertices,
                  //   uvCoords: cubeMesh.uvCoords,
                  //   faceColors: cubeMesh.faceColors,
                  //   faceNormals: cubeMesh.faceNormals,
                  //   elements: cubeMesh.elements,
                  //   face: 1,
                  //   stencilId: s,
                //    axisShift: [
                 //     (0.45*timeSlice - 0.5),
                 //     0,0,
                //    ],
                  // })
                // }
              }
            }

            if(slicesCheckbox.checked) {
              drawLine3D({
                points: sliceABuffer,
                axisFilter: [1,1,1],
                axisShift: [0,0,0],
                model: matrixA,
                color: [1,1,1,1],
                width: 2 * window.devicePixelRatio,
                segments: samples.length-1,
                resolution: [canvas.width,canvas.height],
                depth: true,
                stencilId: 4,
              })

              drawLine3D({
                points: sliceBBuffer,
                axisFilter: [1,1,1],
                axisShift: [0,0,0],
                model: matrixB,
                color: [1,1,1,1],
                width: 2 * window.devicePixelRatio,
                segments: samples.length-1,
                resolution: [canvas.width,canvas.height],
                depth: true,
                stencilId: 4,
              })

              if(shadowCheckbox.checked) {
                drawLine3D({
                  points: sliceABuffer,
                  axisFilter: [0,1,1],
                  axisShift: [-0.5,0,0],
                  model: matrixA,
                  color: [0,0,0,.5],
                  width: 2 * window.devicePixelRatio,
                  segments: samples.length-1,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                  stencilId: 4,
                })

                drawLine3D({
                  points: sliceABuffer,
                  axisFilter: [1,0,1],
                  axisShift: [0,-0.25,0],
                  model: matrixA,
                  color: [0,0,0,.5],
                  width: 2 * window.devicePixelRatio,
                  segments: samples.length-1,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                  stencilId: 4,
                })

                drawLine3D({
                  points: sliceABuffer,
                  axisFilter: [1,1,0],
                  axisShift: [0,0,0.25],
                  model: matrixA,
                  color: [0,0,0,.5],
                  width: 2 * window.devicePixelRatio,
                  segments: samples.length-1,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                  stencilId: 4,
                })

                drawLine3D({
                  points: sliceBBuffer,
                  axisFilter: [0,1,1],
                  axisShift: [-0.5,0,0],
                  model: matrixB,
                  color: [0,0,0,.5],
                  width: 2 * window.devicePixelRatio,
                  segments: samples.length-1,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                  stencilId: 4,
                })

                drawLine3D({
                  points: sliceBBuffer,
                  axisFilter: [1,0,1],
                  axisShift: [0,-0.25,0],
                  model: matrixB,
                  color: [0,0,0,.5],
                  width: 2 * window.devicePixelRatio,
                  segments: samples.length-1,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                  stencilId: 4,
                })

                drawLine3D({
                  points: sliceBBuffer,
                  axisFilter: [1,1,0],
                  axisShift: [0,0,-0.25],
                  model: matrixB,
                  color: [0,0,0,.5],
                  width: 2 * window.devicePixelRatio,
                  segments: samples.length-1,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                  stencilId: 4,
                })
              }
              

              if(axisCheckbox.checked) {
                drawArrow3D({
                  points: arrowBuffer,
                  model: matrixA,
                  color: [0,0,0, 1],
                  width: 2 * window.devicePixelRatio,
                  segments: 3,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                  stencilId: 4,
                })
                drawArrow3D({
                  points: arrowBuffer,
                  model: matrixB,
                  color: [0,0,0, 1],
                  width: 2 * window.devicePixelRatio,
                  segments: 3,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                  stencilId: 4,
                })

                
                if(labelCheckbox.checked) {
                  drawLabel({
                    points: labelBuffer,
                    glyphs: glyphBuffer2,
                    atlas: glypthTexture,
                    offset: [0.5,0.5],
                    model: matrixA,
                    color: [0,0,0, 1],
                    width: 30 * window.devicePixelRatio,
                    resolution: [canvas.width,canvas.height],
                    depth: false,
                    segments: 3,
                    stencilId: 4,
                  })

                  drawLabel({
                    points: labelBuffer,
                    glyphs: glyphBuffer2,
                    atlas: glypthTexture,
                    offset: [0.5,0.5],
                    model: matrixB,
                    color: [0,0,0, 1],
                    width: 30 * window.devicePixelRatio,
                    resolution: [canvas.width,canvas.height],
                    depth: false,
                    segments: 3,
                    stencilId: 4,
                  })
                }
              }
            }
          } else {

            regl.clear({
              color: [0.36, 0.46, 0.96, 1],
              stencil: 0
            })
            for(let s=0;s<4;s++) {
              drawLine3D({
                points: s%2?spectrumBuffer:signalBuffer,
                axisFilter: [1,1,1],
                axisShift: [0,0,0],
                model: rotationMatricesAxisNoCubeFlipped[s],
                color: [1,1,1, 1],
                width: 2 * window.devicePixelRatio,
                segments: samples.length-1,
                resolution: [canvas.width,canvas.height],
                depth: true,
              })

              if(axisCheckbox.checked) {
                drawArrow3D({
                  points: arrowBuffer,
                  model: rotationMatricesAxisNoCube[s],
                  color: [0.2,0.2,0.5, 1],
                  width: 2 * window.devicePixelRatio,
                  segments: s !=4 ? 3 : 2,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                })
              }

              if(labelCheckbox.checked) {
                if(axisCheckbox.checked) {
                  drawLabel({
                    points: labelBuffer,
                    glyphs: s%2 ? glyphBuffer : glyphBuffer2,
                    atlas: glypthTexture,
                    offset: [0.5,0.5],
                    model: rotationMatricesAxisNoCube[s],
                    color: [0,0,0, 1],
                    width: 30 * window.devicePixelRatio,
                    resolution: [canvas.width,canvas.height],
                    depth: false,
                    segments: 3,
                  })
                }

                drawLabel({
                  points: [0,-0.2,0],
                  glyphs: [s%2,s>1?1:0],
                  atlas: glypthTexture2,
                  offset: [0,0],
                  model: rotationMatricesAxisNoCube[s],
                  color: [1,1,1, 0.4],
                  width: 100 * window.devicePixelRatio,
                  resolution: [canvas.width,canvas.height],
                  depth: false,
                  segments: 1,
                })
              }

              if(slicesCheckbox.checked) {
                if(s===1 || s===3) {
                  drawLine3D({
                    points: s%2?spectrumBuffer:signalBuffer,
                    axisFilter: [1,1,1],
                    axisShift: [0,0,0],
                    model: rotationMatricesAxisNoCubeFlipped[s],
                    color: [0.2,0,0.8, 0.8],
                    width: 7 * window.devicePixelRatio,
                    segments: 1,
                    segmentOffset: Math.min(sampleSize-9, freqSliceB + sampleSize/2),
                    segmentLength: 0,
                    resolution: [canvas.width,canvas.height],
                    depth: false,
                  })

                  drawLine3D({
                    points: s%2?spectrumBuffer:signalBuffer,
                    axisFilter: [1,1,1],
                    axisShift: [0,0,0],
                    model: rotationMatricesAxisNoCubeFlipped[s],
                    color: [1,0.1,1, 0.8],
                    width: 7 * window.devicePixelRatio,
                    segments: 1,
                    segmentOffset: Math.min(sampleSize-9, freqSliceA + sampleSize/2),
                    segmentLength: 0,
                    resolution: [canvas.width,canvas.height],
                    depth: false,
                  })
                }

                // if(s===2) {
                //  drawFace({
                  //   positions: cubeMesh.vertices,
                  //   uvCoords: cubeMesh.uvCoords,
                  //   faceColors: cubeMesh.faceColors,
                  //   faceNormals: cubeMesh.faceNormals,
                  //   elements: cubeMesh.elements,
                  //   face: 1,
                  //   stencilId: s,
                //    axisShift: [
                 //     (0.45*timeSlice - 0.5),
                 //     0,0,
                //    ],
                  // })
                // }
              }
            }

            if(slicesCheckbox.checked) {
              drawLine3D({
                points: sliceABuffer,
                axisFilter: [1,1,1],
                axisShift: [0,0,0],
                model: matrixANoCube,
                color: [1,0.1,1,1],
                width: 2 * window.devicePixelRatio,
                segments: samples.length-1,
                resolution: [canvas.width,canvas.height],
                depth: true,
              })

            
              drawLine3D({
                points: sliceBBuffer,
                axisFilter: [1,1,1],
                axisShift: [0,0,0],
                model: matrixBNoCube,
                color: [0.2,0,0.8,1],
                width: 2 * window.devicePixelRatio,
                segments: samples.length-1,
                resolution: [canvas.width,canvas.height],
                depth: true,
              })
              

              if(axisCheckbox.checked) {
                drawArrow3D({
                  points: arrowBuffer,
                  model: matrixANoCube,
                  color: [0,0,0, 1],
                  width: 2 * window.devicePixelRatio,
                  segments: 3,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                })

                drawArrow3D({
                  points: arrowBuffer,
                  model: matrixBNoCube,
                  color: [0,0,0, 1],
                  width: 2 * window.devicePixelRatio,
                  segments: 3,
                  resolution: [canvas.width,canvas.height],
                  depth: true,
                })

                
                if(labelCheckbox.checked) {
                  drawLabel({
                    points: labelBuffer,
                    glyphs: glyphBuffer2,
                    atlas: glypthTexture,
                    offset: [0.5,0.5],
                    model: matrixANoCube,
                    color: [0,0,0, 1],
                    width: 30 * window.devicePixelRatio,
                    resolution: [canvas.width,canvas.height],
                    depth: false,
                    segments: 3,
                  })

                  drawLabel({
                    points: labelBuffer,
                    glyphs: glyphBuffer2,
                    atlas: glypthTexture,
                    offset: [0.5,0.5],
                    model: matrixBNoCube,
                    color: [0,0,0, 1],
                    width: 30 * window.devicePixelRatio,
                    resolution: [canvas.width,canvas.height],
                    depth: false,
                    segments: 3,
                  })
                }
              }
            }
          }
        })
      })
    </script>
</body>
</html>
